// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gtfs-realtime-realcity.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// realCity extensions for the GTFS-realtime protocol

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Realcity_VehicleDescriptor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var vehicleModel: String {
    get {return _vehicleModel ?? String()}
    set {_vehicleModel = newValue}
  }
  /// Returns true if `vehicleModel` has been explicitly set.
  var hasVehicleModel: Bool {return self._vehicleModel != nil}
  /// Clears the value of `vehicleModel`. Subsequent reads from it will return its default value.
  mutating func clearVehicleModel() {self._vehicleModel = nil}

  var deviated: Bool {
    get {return _deviated ?? false}
    set {_deviated = newValue}
  }
  /// Returns true if `deviated` has been explicitly set.
  var hasDeviated: Bool {return self._deviated != nil}
  /// Clears the value of `deviated`. Subsequent reads from it will return its default value.
  mutating func clearDeviated() {self._deviated = nil}

  var vehicleType: Int32 {
    get {return _vehicleType ?? 0}
    set {_vehicleType = newValue}
  }
  /// Returns true if `vehicleType` has been explicitly set.
  var hasVehicleType: Bool {return self._vehicleType != nil}
  /// Clears the value of `vehicleType`. Subsequent reads from it will return its default value.
  mutating func clearVehicleType() {self._vehicleType = nil}

  var doorOpen: Bool {
    get {return _doorOpen ?? false}
    set {_doorOpen = newValue}
  }
  /// Returns true if `doorOpen` has been explicitly set.
  var hasDoorOpen: Bool {return self._doorOpen != nil}
  /// Clears the value of `doorOpen`. Subsequent reads from it will return its default value.
  mutating func clearDoorOpen() {self._doorOpen = nil}

  var stopDistance: Int32 {
    get {return _stopDistance ?? 0}
    set {_stopDistance = newValue}
  }
  /// Returns true if `stopDistance` has been explicitly set.
  var hasStopDistance: Bool {return self._stopDistance != nil}
  /// Clears the value of `stopDistance`. Subsequent reads from it will return its default value.
  mutating func clearStopDistance() {self._stopDistance = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _vehicleModel: String? = nil
  fileprivate var _deviated: Bool? = nil
  fileprivate var _vehicleType: Int32? = nil
  fileprivate var _doorOpen: Bool? = nil
  fileprivate var _stopDistance: Int32? = nil
}

struct Realcity_StopTimeUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scheduledArrival: TransitRealtime_TripUpdate.StopTimeEvent {
    get {return _scheduledArrival ?? TransitRealtime_TripUpdate.StopTimeEvent()}
    set {_scheduledArrival = newValue}
  }
  /// Returns true if `scheduledArrival` has been explicitly set.
  var hasScheduledArrival: Bool {return self._scheduledArrival != nil}
  /// Clears the value of `scheduledArrival`. Subsequent reads from it will return its default value.
  mutating func clearScheduledArrival() {self._scheduledArrival = nil}

  var scheduledDeparture: TransitRealtime_TripUpdate.StopTimeEvent {
    get {return _scheduledDeparture ?? TransitRealtime_TripUpdate.StopTimeEvent()}
    set {_scheduledDeparture = newValue}
  }
  /// Returns true if `scheduledDeparture` has been explicitly set.
  var hasScheduledDeparture: Bool {return self._scheduledDeparture != nil}
  /// Clears the value of `scheduledDeparture`. Subsequent reads from it will return its default value.
  mutating func clearScheduledDeparture() {self._scheduledDeparture = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scheduledArrival: TransitRealtime_TripUpdate.StopTimeEvent? = nil
  fileprivate var _scheduledDeparture: TransitRealtime_TripUpdate.StopTimeEvent? = nil
}

struct Realcity_RouteDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  mutating func clearRouteID() {self._routeID = nil}

  var headerText: TransitRealtime_TranslatedString {
    get {return _headerText ?? TransitRealtime_TranslatedString()}
    set {_headerText = newValue}
  }
  /// Returns true if `headerText` has been explicitly set.
  var hasHeaderText: Bool {return self._headerText != nil}
  /// Clears the value of `headerText`. Subsequent reads from it will return its default value.
  mutating func clearHeaderText() {self._headerText = nil}

  var cause: TransitRealtime_Alert.Cause {
    get {return _cause ?? .unknownCause}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  mutating func clearCause() {self._cause = nil}

  var effect: TransitRealtime_Alert.Effect {
    get {return _effect ?? .noService}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  mutating func clearEffect() {self._effect = nil}

  var effectType: Realcity_RouteDetail.EffectType {
    get {return _effectType ?? .noService}
    set {_effectType = newValue}
  }
  /// Returns true if `effectType` has been explicitly set.
  var hasEffectType: Bool {return self._effectType != nil}
  /// Clears the value of `effectType`. Subsequent reads from it will return its default value.
  mutating func clearEffectType() {self._effectType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum EffectType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noService = 1
    case warning = 2

    init() {
      self = .noService
    }

  }

  init() {}

  fileprivate var _routeID: String? = nil
  fileprivate var _headerText: TransitRealtime_TranslatedString? = nil
  fileprivate var _cause: TransitRealtime_Alert.Cause? = nil
  fileprivate var _effect: TransitRealtime_Alert.Effect? = nil
  fileprivate var _effectType: Realcity_RouteDetail.EffectType? = nil
}

struct Realcity_Alert: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startText: TransitRealtime_TranslatedString {
    get {return _startText ?? TransitRealtime_TranslatedString()}
    set {_startText = newValue}
  }
  /// Returns true if `startText` has been explicitly set.
  var hasStartText: Bool {return self._startText != nil}
  /// Clears the value of `startText`. Subsequent reads from it will return its default value.
  mutating func clearStartText() {self._startText = nil}

  var endText: TransitRealtime_TranslatedString {
    get {return _endText ?? TransitRealtime_TranslatedString()}
    set {_endText = newValue}
  }
  /// Returns true if `endText` has been explicitly set.
  var hasEndText: Bool {return self._endText != nil}
  /// Clears the value of `endText`. Subsequent reads from it will return its default value.
  mutating func clearEndText() {self._endText = nil}

  var modifiedTime: UInt64 {
    get {return _modifiedTime ?? 0}
    set {_modifiedTime = newValue}
  }
  /// Returns true if `modifiedTime` has been explicitly set.
  var hasModifiedTime: Bool {return self._modifiedTime != nil}
  /// Clears the value of `modifiedTime`. Subsequent reads from it will return its default value.
  mutating func clearModifiedTime() {self._modifiedTime = nil}

  var route: [Realcity_RouteDetail] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startText: TransitRealtime_TranslatedString? = nil
  fileprivate var _endText: TransitRealtime_TranslatedString? = nil
  fileprivate var _modifiedTime: UInt64? = nil
}

// MARK: - Extension support defined in gtfs-realtime-realcity.proto.

// MARK: - Extension Properties

// Swift Extensions on the extended Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension TransitRealtime_Alert {

  var Realcity_alert: Realcity_Alert {
    get {return getExtensionValue(ext: Realcity_Extensions_alert) ?? Realcity_Alert()}
    set {setExtensionValue(ext: Realcity_Extensions_alert, value: newValue)}
  }
  /// Returns true if extension `Realcity_Extensions_alert`
  /// has been explicitly set.
  var hasRealcity_alert: Bool {
    return hasExtensionValue(ext: Realcity_Extensions_alert)
  }
  /// Clears the value of extension `Realcity_Extensions_alert`.
  /// Subsequent reads from it will return its default value.
  mutating func clearRealcity_alert() {
    clearExtensionValue(ext: Realcity_Extensions_alert)
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate {

  var Realcity_stopTimeUpdate: Realcity_StopTimeUpdate {
    get {return getExtensionValue(ext: Realcity_Extensions_stop_time_update) ?? Realcity_StopTimeUpdate()}
    set {setExtensionValue(ext: Realcity_Extensions_stop_time_update, value: newValue)}
  }
  /// Returns true if extension `Realcity_Extensions_stop_time_update`
  /// has been explicitly set.
  var hasRealcity_stopTimeUpdate: Bool {
    return hasExtensionValue(ext: Realcity_Extensions_stop_time_update)
  }
  /// Clears the value of extension `Realcity_Extensions_stop_time_update`.
  /// Subsequent reads from it will return its default value.
  mutating func clearRealcity_stopTimeUpdate() {
    clearExtensionValue(ext: Realcity_Extensions_stop_time_update)
  }
}

extension TransitRealtime_VehicleDescriptor {

  var Realcity_vehicle: Realcity_VehicleDescriptor {
    get {return getExtensionValue(ext: Realcity_Extensions_vehicle) ?? Realcity_VehicleDescriptor()}
    set {setExtensionValue(ext: Realcity_Extensions_vehicle, value: newValue)}
  }
  /// Returns true if extension `Realcity_Extensions_vehicle`
  /// has been explicitly set.
  var hasRealcity_vehicle: Bool {
    return hasExtensionValue(ext: Realcity_Extensions_vehicle)
  }
  /// Clears the value of extension `Realcity_Extensions_vehicle`.
  /// Subsequent reads from it will return its default value.
  mutating func clearRealcity_vehicle() {
    clearExtensionValue(ext: Realcity_Extensions_vehicle)
  }

}

// MARK: - File's ExtensionMap: Realcity_Gtfs_u45Realtime_u45Realcity_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
let Realcity_Gtfs_u45Realtime_u45Realcity_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  Realcity_Extensions_vehicle,
  Realcity_Extensions_stop_time_update,
  Realcity_Extensions_alert
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

let Realcity_Extensions_vehicle = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Realcity_VehicleDescriptor>, TransitRealtime_VehicleDescriptor>(
  _protobuf_fieldNumber: 1006,
  fieldName: "realcity.vehicle"
)

let Realcity_Extensions_stop_time_update = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Realcity_StopTimeUpdate>, TransitRealtime_TripUpdate.StopTimeUpdate>(
  _protobuf_fieldNumber: 1006,
  fieldName: "realcity.stop_time_update"
)

let Realcity_Extensions_alert = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<Realcity_Alert>, TransitRealtime_Alert>(
  _protobuf_fieldNumber: 1006,
  fieldName: "realcity.alert"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "realcity"

extension Realcity_VehicleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VehicleDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vehicle_model"),
    2: .same(proto: "deviated"),
    3: .standard(proto: "vehicle_type"),
    4: .standard(proto: "door_open"),
    5: .standard(proto: "stop_distance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._vehicleModel) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._deviated) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._vehicleType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._doorOpen) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self._stopDistance) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vehicleModel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._deviated {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._vehicleType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._doorOpen {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._stopDistance {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Realcity_VehicleDescriptor, rhs: Realcity_VehicleDescriptor) -> Bool {
    if lhs._vehicleModel != rhs._vehicleModel {return false}
    if lhs._deviated != rhs._deviated {return false}
    if lhs._vehicleType != rhs._vehicleType {return false}
    if lhs._doorOpen != rhs._doorOpen {return false}
    if lhs._stopDistance != rhs._stopDistance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Realcity_StopTimeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StopTimeUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scheduled_arrival"),
    2: .standard(proto: "scheduled_departure"),
  ]

  public var isInitialized: Bool {
    if let v = self._scheduledArrival, !v.isInitialized {return false}
    if let v = self._scheduledDeparture, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scheduledArrival) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduledDeparture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scheduledArrival {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scheduledDeparture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Realcity_StopTimeUpdate, rhs: Realcity_StopTimeUpdate) -> Bool {
    if lhs._scheduledArrival != rhs._scheduledArrival {return false}
    if lhs._scheduledDeparture != rhs._scheduledDeparture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Realcity_RouteDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteDetail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_id"),
    2: .standard(proto: "header_text"),
    3: .same(proto: "cause"),
    4: .same(proto: "effect"),
    5: .standard(proto: "effect_type"),
  ]

  public var isInitialized: Bool {
    if self._routeID == nil {return false}
    if let v = self._headerText, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._headerText) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._cause) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._effect) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._effectType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._headerText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cause {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._effect {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._effectType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Realcity_RouteDetail, rhs: Realcity_RouteDetail) -> Bool {
    if lhs._routeID != rhs._routeID {return false}
    if lhs._headerText != rhs._headerText {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs._effectType != rhs._effectType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Realcity_RouteDetail.EffectType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NO_SERVICE"),
    2: .same(proto: "WARNING"),
  ]
}

extension Realcity_Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Alert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startText"),
    2: .same(proto: "endText"),
    3: .same(proto: "modifiedTime"),
    4: .same(proto: "route"),
  ]

  public var isInitialized: Bool {
    if let v = self._startText, !v.isInitialized {return false}
    if let v = self._endText, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.route) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startText) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endText) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._modifiedTime) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._modifiedTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.route.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.route, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Realcity_Alert, rhs: Realcity_Alert) -> Bool {
    if lhs._startText != rhs._startText {return false}
    if lhs._endText != rhs._endText {return false}
    if lhs._modifiedTime != rhs._modifiedTime {return false}
    if lhs.route != rhs.route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
